# Crypto

[cyberchef](https://gchq.github.io/CyberChef)

**对称加密：流加密和块加密**

- ECB
- CBC
- CTR

RSA
ECC
椭圆曲线 $y^2 = x ^3 +ax+b$

**中文说明**

- **ECB（电子密码本模式）:** : ECB 将明文按固定块分割，对每个块单独加密。优点是实现简单、并行性好；缺点是相同行明文块会得到相同密文块，会泄露数据模式（不适合加密图像或有重复结构的数据）。
- **CBC（密码分组链式）:** : CBC 在加密时将每个明文块与前一密文块异或（第一块用初始化向量 IV），然后再加密。优点是能消除相同明文块的可见性；缺点是串行处理、对 IV 的随机性依赖强。
- **CTR（计数器模式）:** : CTR 将一个计数器值加密后与明文异或，等价于流密码，支持并行，加密/解密对称且性能高。必须保证计数器（或 IV）不重复，否则会被重放/回退攻击。

- **RSA（非对称加密）:** : 基于大整数因式分解困难性，生成两个大素数 p、q，模 n=p*q。公钥通常由 `(n, e)` 组成，私钥由 `d`（以及 `p,q` 等可选值）组成。RSA 可用于加密和签名，但在实际使用中应配合填充（如 OAEP、PSS）以防止确定性或选择明文攻击。
- **ECC（椭圆曲线密码学）:** : 基于椭圆曲线离散对数问题（ECDLP），常用的曲线有 secp256k1、curve25519 等。密钥由曲线参数、生成点 `G` 与私钥标量 `d` 构成，公钥是点乘得到的曲线点 `Q = dG`。与 RSA 相比，ECC 在相同安全强度下使用更短的密钥，性能更好（签名、密钥交换效率高）。

**ECC 与 RSA 的公钥/私钥横向对比**

- **基本假设（安全基石）:** :
	- **RSA：** 依赖整数因式分解问题（IFP），攻击者需因式分解 `n` 才能恢复私钥。
	- **ECC：** 依赖椭圆曲线离散对数问题（ECDLP），攻击者需解出 `d` 使得 `Q = dG`。

- **密钥表示与结构（公钥 / 私钥）:** :
	- **RSA 公钥：** `(n, e)`，其中 `n = p * q`（大整数），`e` 是公用指数（常用 65537）。
	- **RSA 私钥：** 私钥 `d`，以及可选的 `p,q,dP,dQ,qInv` 用于加速（CRT）。
	- **ECC 公钥：** 一个曲线点 `Q = (x, y)`（或压缩表示只包含 `x` 和一个符号位），外加曲线参数和基点 `G`（通常参数是预定义的）。
	- **ECC 私钥：** 私有标量 `d`（一个在域内的整数）。

- **密钥尺寸与安全性对比：** :
	- ECC 的密钥在比特长度上远小于 RSA，但能提供相同的安全强度。例如，约 256 位的 ECC 相当于 3072 位的 RSA（基于当前主流安全估计）。这意味着存储、传输与计算效率上 ECC 更优。

- **性能（计算/内存）:** :
	- **RSA：** 大模幂运算（如 c = m^e mod n）是计算密集型的，私钥操作（使用 d）通常比公钥耗时多；使用 CRT 可显著加速私钥操作。
	- **ECC：** 点乘运算在较短整数下完成，通常比 RSA 快（尤其是在签名、密钥交换场景），且占用内存和带宽更少。

- **密文/签名大小与带宽:** :
	- **RSA：** 密文或签名大小通常与模长 n 的字节长度一致（例如 2048-bit RSA 生成 256 字节的签名）。
	- **ECC：** 签名或共享密钥通常更短（例如 ECDSA 签名与曲线参数有关，常见压缩后远小于 RSA）。

- **使用场景与协议支持:** :
	- **RSA：** 广泛用于 TLS、S/MIME、PGP 等（尤其是历史遗留系统与证书体系），易于理解与实现。
	- **ECC：** 越来越被现代协议采纳（如 TLS 1.3、移动与嵌入式设备常用 ECC 以节省资源），在区块链与移动安全中广泛使用。

- **安全注意事项与漏洞面:** :
	- **RSA：** 需要合适填充（OAEP 用于加密，PSS 用于签名）；选择不安全参数或使用可预测随机数会导致密钥或填充被破坏。若 `p`、`q` 相关（如示例代码中 p 与 q 存在某种比特反转关系），可能弱化安全性并简化因式分解。
	- **ECC：** 曲线参数选择至关重要（避免使用有已知弱点或后门的曲线）；实现上需要防止侧信道泄露（恒时操作、随机化算法），并注意点验证以避免小子群攻击。

- **量子抗性:** :
	- 传统的 RSA 与 ECC 在量子计算机足够大时都会被 Shor 算法击破；因此对未来安全的要求应考虑后量子密码算法（NIST 正在标准化）。

**总结要点**

- **公钥结构差异核心一行话：** RSA 公钥由大整数模 `n` 与指数 `e` 组成；ECC 公钥是曲线上的点 `Q = dG`（依赖曲线参数和生成点）。
- **实际选择建议：** 若受限于带宽/存储/计算，优先考虑 ECC（在正确选择曲线与安全实现下）。若需要最大兼容性或现有基础设施依赖，RSA 仍是可行选择，但务必采用合适填充与足够的模长。 

**对称 / 非对称 加密分类与主要区别**

- **哪些是对称加密：** ECB、CBC、CTR（这些都是基于对称密钥的分组/流密码模式）。对称加密使用相同的密钥进行加密和解密，适合对大量数据进行高性能加密，但需要安全地分发和保存共享密钥。
- **哪些是非对称加密：** RSA、ECC（基于公钥/私钥对）。非对称加密使用一对密钥：公钥可公开、用于加密或验证签名；私钥保密、用于解密或生成签名，常用于密钥交换、数字签名和建立信任。

- **主要区别（简要对比）：**
	- **密钥数量与分配：** 对称只有一把共享密钥；非对称每个参与方有公私钥对，便于公开分发公钥。
	- **性能：** 对称算法（如 AES）在大数据块上更快、更省资源；非对称算法（RSA/ECC）在计算上更慢，常用于少量数据或用于加密会话密钥。
	- **用途：** 对称适合数据加密（会话加密）；非对称用于密钥协商、身份认证与数字签名。
	- **安全与可扩展性：** 非对称便于扩展（无需为每一对通信方共享单独密钥），但私钥泄露会带来严重后果；对称在密钥管理上更麻烦（N 个节点需要 O(N^2) 把密钥）。
	- **示例组合使用：** 在实际协议中常混合使用：用非对称算法交换或签发对称会话密钥，再用对称算法加密会话数据（例如 TLS）。

**小结：** 对称与非对称各有优势——对称高效但需安全分发密钥；非对称便于密钥管理和签名，但计算成本较高。实际系统通常把两者结合以兼顾性能与可用性。

**数字签名**

- **定义与目的：** 数字签名是用私钥对数据（或数据摘要）进行加密学处理，生成能够被公钥验证的签名。目的包括：身份认证（证明签名者）、数据完整性（检测篡改）和不可否认性（签名者难以否认其签署行为）。

- **基本流程：**
	1. 对消息应用安全哈希函数得到摘要 `h = H(m)`；
	2. 用私钥对摘要进行签名（签名算法依赖于 RSA/ECC/EdDSA 等）；
	3. 验证方用签名者的公钥验证签名是否针对 `H(m)` 成立。

- **常见签名算法：**
	- **RSA-PSS：** RSA 的现代签名方案，使用随机填充（PSS），安全性高于老式 RSA 签名。 
	- **ECDSA：** 基于椭圆曲线的签名（需保证随机 nonce 的安全性，否则私钥会泄露）。
	- **EdDSA（如 Ed25519）：** 现代、速度快且实现上更容易避免侧信道问题的椭圆曲线签名。

- **性质对比与注意点：**
	- **签名大小与性能：** ECC 系列签名通常比 RSA 签名短且更高效（相同安全等级下）。
	- **随机性：** 某些签名（如 ECDSA）在签名时需要安全随机数；若重复或可预测，会直接泄露私钥。EdDSA 使用确定性方案（基于哈希）减少此类风险。
	- **哈希依赖：** 总是在签名前对消息做哈希，以缩短输入并提高效率；选择安全哈希（如 SHA-256 家族）。
	- **抗篡改与不可否认性：** 签名保证消息在验证者看来来自某个私钥持有者，但需结合时间戳、证书体系或第三方见证以增强法律/管理层面的可证明性。

- **实践建议：**
	- 使用经审计的现代方案（RSA-PSS、Ed25519）；避免直接使用不带填充的 RSA 签名或自造变体。
	- 保护私钥（硬件安全模块 HSM、专用密钥存储），并对签名流程做抗侧信道设计。
	- 在协议中结合证书链、撤销列表和时间戳服务，确保签名验证的完整性与时效性。

**小结：** 数字签名是建立信任与验证完整性的核心工具，选择合适的算法与实现细节（填充、哈希、随机性、密钥保护）对安全性至关重要。


***

下面给出 Feistel 结构可逆性的简明推导、直观说明和复原流程。

**核心变换**  
每一轮的加密变换为
$$(L_{i+1},\,R_{i+1})=(R_i,\;L_i\oplus F(R_i,k_{i+1}))$$
其中 $F$ 是任意轮函数，$\oplus$ 为按位异或（XOR）。

**逆向推导（从第 i+1 轮回退到第 i 轮）**  
已知 $(L_{i+1},R_{i+1})$，要求 $(L_i,R_i)$：
- 由加密公式第一分量得： $R_i=L_{i+1}$。
- 代回第二分量可解出 $L_i$：
  $$R_{i+1}=L_i\oplus F(R_i,k_{i+1})=L_i\oplus F(L_{i+1},k_{i+1})$$
  因此
  $$L_i=R_{i+1}\oplus F(L_{i+1},k_{i+1}).$$

所以逆变换为
$$(R_i,L_i)=(L_{i+1},\;R_{i+1}\oplus F(L_{i+1},k_{i+1})).$$

**直观原因（为何总可逆）**  
- XOR 是可逆运算：若 $a\oplus b=c$，则 $a=c\oplus b$。  
- 每轮同时做一次“交换”（左/右互换）和一次基于右半区的 XOR 混合，交换保留了右半区的信息，XOR 用相同的输入（解密时代入已知的右半区）即可恢复左半区。  
- 因此即便 $F$ 本身不可逆，也不影响整体可逆性——因为解密不需要反算 $F$，只需用同样的 $F$ 与已知量再次 XOR。

**解密流程（整体）**  
若加密用 $n$ 轮并依次使用子密钥 $k_1,\dots,k_n$，解密按逆序使用相同的 $F$ 与子密钥：
从 $(L_n,R_n)$，对 i 从 n 到 1 做
$$R_{i-1}=L_i,\qquad L_{i-1}=R_i\oplus F(L_i,k_i)$$
最终得到原始 $(L_0,R_0)$。

**小示例（两轮符号演示）**  
- 加密：  
  1) $(L_1,R_1)=(R_0,\;L_0\oplus F(R_0,k_1))$  
  2) $(L_2,R_2)=(R_1,\;L_1\oplus F(R_1,k_2))$  
- 解密（反向）：由 $(L_2,R_2)$ 得到 $(L_1,R_1)$，再得到 $(L_0,R_0)$，每步按上述逆向公式计算即可完全恢复原文。

结论：Feistel 结构“通过交换+XOR”的设计内建可逆性，解密只需按轮序倒序、用相同的 $F$ 和子密钥计算即可。